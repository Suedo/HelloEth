# Solidity Basics

Starting off with what I am learning from this Udemy course. Most tutorials are based on older compiler versions. Planning to add advanced stuff once basics are done

[Code with Ethereum & Solidity: The Complete Developer Guide](https://www.udemy.com/course/ethereum-and-solidity-the-complete-developers-guide/)


## Constructor

this block gets executed when we are deploying the code to the blockchain. Only one constructor is allowed, thus no overloading.

```jsx
constructor() public {
	// logic here
}
```

## Keywords/concepts to check:

view, payable, public, enum, mapping, returns (in method signature), transfer, msg.sender, msg.value, ownership, transfer ownership, require, assert, "modifier" being used to generate checks which can be added to method signature, events, receive function, why receive functions needs to be marked external, Inheritance, Factories, Smart Contract Interactions, 

## Pure functions vs View Functions

Functions declared as a `[view](https://solidity.readthedocs.io/en/v0.7.4/contracts.html?#view-functions)` promise not to modify the state of the contract. Whereas Functions declared as `[pure](https://solidity.readthedocs.io/en/v0.7.4/contracts.html?#pure-functions)` promise not to modify the state, nor read the state of a contract. 

Note: If the compilerâ€™s EVM target is Byzantium or newer (default) the opcode `STATICCALL` is used, which does not guarantee that the state is not read, but at least that it is not modified.

## Function Modifiers

Modifiers can be used to change the behavior of functions in a declarative way. Modifiers are inheritable properties of contracts and may be overridden by derived contracts, but only if they are marked `virtual`. More details [here](https://solidity.readthedocs.io/en/v0.7.4/contracts.html?#function-modifiers).

```jsx
pragma solidity >0.7.0 <0.8.0;

contract owned {
    constructor() { owner = msg.sender; }
    address payable owner;

    // This contract only defines a modifier but does not use it: 
    // it will be used in derived contracts. The function body is inserted where 
    // the special symbol `_;` in the definition of a modifier appears. This means that 
    // if the owner calls this function, the function is executed and otherwise, an exception is thrown.
    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
}

contract destructible is owned {
    // This contract inherits the `onlyOwner` modifier from `owned` and applies it to the
    // `destroy` function, which causes that calls to `destroy` 
    // only have an effect if they are made by the stored owner.
    function destroy() public onlyOwner {
        selfdestruct(owner);
    }
}
```

## Return Values

Solidity programs can return multiple values. Also, the return signature on the method has names of variables. We can directly assign to these named variables, and skip the `return` keyword inside the function body, or, be more traditional like other languages, and have a `return` statement that matches the signature of the function, without paying much heed to the names of the variables in the method's return signature. Below are two methods of returning as described:

```jsx
pragma solidity >=0.4.16 <0.8.0;

// Method 1: assign to return variables
contract Simple {
    function arithmetic(uint _a, uint _b) public pure
        returns (uint o_sum, uint o_product) { 
        o_sum = _a + _b;
        o_product = _a * _b;
    }
}

// Method 2: use traditional return statement
contract Simple {
    function arithmetic(uint _a, uint _b) public pure
        returns (uint o_sum, uint o_product) {
        return (_a + _b, _a * _b);
    }
}
```